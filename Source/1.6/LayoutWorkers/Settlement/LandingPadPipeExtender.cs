using System.Collections.Generic;
using BetterTradersGuild.DefRefs;
using RimWorld;
using Verse;

namespace BetterTradersGuild.LayoutWorkers.Settlement
{
    /// <summary>
    /// Extends VE pipe networks from main settlement structure to external
    /// landing pads by following OrbitalPlatform terrain strips.
    ///
    /// PURPOSE:
    /// Provides thematic realism for traders' guild refueling stations by
    /// connecting fluid resource networks (chemfuel, nutrient paste, oxygen,
    /// astrofuel) to ship landing areas for docked vessel resupply.
    ///
    /// TECHNICAL APPROACH:
    /// - Uses LandingPadDetector to find external landing pads via beacon markers
    /// - Traces A* paths from pad edges back to main structure following terrain
    /// - Places visible VE pipes along the paths
    ///
    /// LEARNING NOTE (A* vs BFS):
    /// A* is preferred over BFS for terrain-following pathfinding because we have
    /// a clear target (structure center). BFS explores uniformly in all directions,
    /// wasting iterations. A* uses Manhattan distance heuristic to prioritize cells
    /// closer to the goal, finding paths much more efficiently within iteration limits.
    ///
    /// LEARNING NOTE (External vs Internal Generation):
    /// External landing pads are NOT part of LayoutStructureSketch - they're
    /// procedurally generated by vanilla GenStep_OrbitalPlatform separately.
    /// We detect them post-generation via beacon markers.
    /// </summary>
    public static class LandingPadPipeExtender
    {
        /// <summary>
        /// Extends VE pipes from structure to all external landing pads.
        /// </summary>
        public static void ExtendPipesToLandingPads(Map map, LayoutStructureSketch sketch)
        {
            // Verify required defs are available
            if (Terrains.OrbitalPlatform == null || Things.OrbitalAncientFortifiedWall == null) return;

            // Get visible VE pipe defs for fluid networks
            List<ThingDef> visiblePipeDefs = BuildVisiblePipeDefsList();
            if (visiblePipeDefs.Count == 0) return;

            // Sanity check
            if (sketch?.structureLayout == null) return;

            CellRect structureRect = sketch.structureLayout.container;

            // Detect landing pads via beacons (external to structure)
            List<LandingPadDetector.LandingPadInfo> landingPads = LandingPadDetector.DetectOutsideRect(map, structureRect);
            if (landingPads.Count == 0) return;

            // Track all placed positions to avoid duplicates
            HashSet<IntVec3> placedCells = new HashSet<IntVec3>();

            // For each landing pad, trace path to structure and place pipes
            foreach (LandingPadDetector.LandingPadInfo pad in landingPads)
            {
                List<IntVec3> path = FindTerrainPathToStructure(map, pad, structureRect);
                if (path.Count > 0)
                {
                    PlacePipesAlongPath(map, path, structureRect, visiblePipeDefs, placedCells);
                }
            }
        }

        /// <summary>
        /// Builds list of visible VE pipe ThingDefs for installed mods.
        /// Uses DefRefs/Things.cs for centralized def resolution.
        /// These are used on external landing pad paths instead of hidden pipes.
        /// </summary>
        private static List<ThingDef> BuildVisiblePipeDefsList()
        {
            List<ThingDef> visiblePipes = new List<ThingDef>();

            // VE Chemfuel visible pipes
            if (Things.VCHE_ChemfuelPipe != null)
                visiblePipes.Add(Things.VCHE_ChemfuelPipe);

            // VE Nutrient Paste visible pipes
            if (Things.VNPE_NutrientPastePipe != null)
                visiblePipes.Add(Things.VNPE_NutrientPastePipe);

            // VE Gravships visible pipes
            if (Things.VGE_OxygenPipe != null)
                visiblePipes.Add(Things.VGE_OxygenPipe);
            if (Things.VGE_AstrofuelPipe != null)
                visiblePipes.Add(Things.VGE_AstrofuelPipe);

            return visiblePipes;
        }

        /// <summary>
        /// Finds a path from landing pad edge toward main structure,
        /// following OrbitalPlatform terrain using A* pathfinding.
        /// </summary>
        private static List<IntVec3> FindTerrainPathToStructure(
            Map map,
            LandingPadDetector.LandingPadInfo padInfo,
            CellRect structureRect)
        {
            // Find the edge of the pad closest to the structure
            IntVec3 structureCenter = structureRect.CenterCell;

            // Determine which side of the pad faces the structure
            IntVec3 startCell = FindClosestPadEdgeToStructure(padInfo.BoundingRect, structureCenter);

            // A* from pad edge toward structure wall
            return FindTerrainPathAStar(map, startCell, structureCenter, maxIterations: 5000);
        }

        /// <summary>
        /// Finds the cell on the pad's bounding rect edge closest to the structure center.
        /// </summary>
        private static IntVec3 FindClosestPadEdgeToStructure(CellRect padRect, IntVec3 structureCenter)
        {
            // Check which direction the structure is from the pad
            IntVec3 padCenter = padRect.CenterCell;
            int dx = structureCenter.x - padCenter.x;
            int dz = structureCenter.z - padCenter.z;

            // Pick edge based on direction
            if (System.Math.Abs(dx) > System.Math.Abs(dz))
            {
                // Structure is more horizontal (left/right)
                if (dx > 0)
                {
                    // Structure is to the right, use right edge
                    return new IntVec3(padRect.maxX, 0, padRect.CenterCell.z);
                }
                else
                {
                    // Structure is to the left, use left edge
                    return new IntVec3(padRect.minX, 0, padRect.CenterCell.z);
                }
            }
            else
            {
                // Structure is more vertical (up/down)
                if (dz > 0)
                {
                    // Structure is above, use top edge
                    return new IntVec3(padRect.CenterCell.x, 0, padRect.maxZ);
                }
                else
                {
                    // Structure is below, use bottom edge
                    return new IntVec3(padRect.CenterCell.x, 0, padRect.minZ);
                }
            }
        }

        /// <summary>
        /// A* pathfinding that follows OrbitalPlatform terrain until reaching the structure wall.
        /// Uses Manhattan distance heuristic to prioritize cells closer to the target.
        /// </summary>
        /// <remarks>
        /// Two-phase approach for robustness:
        /// 1. Phase 1: Follow OrbitalPlatform terrain toward the structure, looking for
        ///    OrbitalAncientFortifiedWall specifically (the settlement perimeter wall)
        /// 2. Phase 2: If terrain ends before reaching the wall, bridge through any passable
        ///    cells until we find OrbitalAncientFortifiedWall or any impassable edifice
        ///
        /// Specifically targets OrbitalAncientFortifiedWall to avoid stopping early at
        /// furniture or other buildings that aren't the actual perimeter wall.
        /// </remarks>
        private static List<IntVec3> FindTerrainPathAStar(
            Map map,
            IntVec3 startCell,
            IntVec3 targetCenter,
            int maxIterations = 5000)
        {
            TerrainDef terrainDef = Terrains.OrbitalPlatform;
            ThingDef wallDef = Things.OrbitalAncientFortifiedWall;

            // If start cell isn't on platform terrain, search nearby for terrain to start from
            if (!startCell.InBounds(map) || map.terrainGrid.TerrainAt(startCell) != terrainDef)
            {
                // Search in expanding rings for platform terrain
                IntVec3? foundStart = null;
                for (int radius = 1; radius <= 5 && foundStart == null; radius++)
                {
                    foreach (IntVec3 cell in GenRadial.RadialCellsAround(startCell, radius, false))
                    {
                        if (cell.InBounds(map) && map.terrainGrid.TerrainAt(cell) == terrainDef)
                        {
                            foundStart = cell;
                            break;
                        }
                    }
                }

                if (foundStart == null)
                    return new List<IntVec3>();

                startCell = foundStart.Value;
            }

            // A* data structures
            Dictionary<IntVec3, IntVec3> cameFrom = new Dictionary<IntVec3, IntVec3>();
            Dictionary<IntVec3, int> gScore = new Dictionary<IntVec3, int>(); // Cost from start
            Dictionary<IntVec3, int> fScore = new Dictionary<IntVec3, int>(); // gScore + heuristic

            HashSet<IntVec3> openSet = new HashSet<IntVec3>();
            HashSet<IntVec3> closedSet = new HashSet<IntVec3>();

            gScore[startCell] = 0;
            fScore[startCell] = ManhattanDistance(startCell, targetCenter);
            openSet.Add(startCell);
            cameFrom[startCell] = startCell;

            int iterations = 0;
            IntVec3? reachedCell = null;
            bool terrainPhaseComplete = false;
            IntVec3? bestTerrainEndCell = null; // Track where terrain phase ended (closest to target)
            int bestTerrainEndDistance = int.MaxValue;

            // Phase 1: Follow OrbitalPlatform terrain, looking specifically for the perimeter wall
            while (openSet.Count > 0 && iterations < maxIterations)
            {
                iterations++;

                IntVec3 current = GetLowestFScore(openSet, fScore);
                openSet.Remove(current);
                closedSet.Add(current);

                // Check if we've reached the specific perimeter wall (OrbitalAncientFortifiedWall)
                if (wallDef != null && IsAdjacentToWallDef(map, current, wallDef))
                {
                    reachedCell = current;
                    break;
                }

                // Track the cell closest to target in case we need phase 2
                int distToTarget = ManhattanDistance(current, targetCenter);
                if (distToTarget < bestTerrainEndDistance)
                {
                    bestTerrainEndDistance = distToTarget;
                    bestTerrainEndCell = current;
                }

                // Explore cardinal neighbors - terrain-only in phase 1
                bool foundTerrainNeighbor = false;
                foreach (IntVec3 neighbor in CardinalNeighbors(current))
                {
                    if (!neighbor.InBounds(map))
                        continue;
                    if (closedSet.Contains(neighbor))
                        continue;
                    if (map.terrainGrid.TerrainAt(neighbor) != terrainDef)
                        continue;

                    foundTerrainNeighbor = true;
                    int tentativeGScore = gScore[current] + 1;

                    if (!openSet.Contains(neighbor))
                    {
                        openSet.Add(neighbor);
                    }
                    else if (gScore.TryGetValue(neighbor, out int existingG) && tentativeGScore >= existingG)
                    {
                        continue;
                    }

                    cameFrom[neighbor] = current;
                    gScore[neighbor] = tentativeGScore;
                    fScore[neighbor] = tentativeGScore + ManhattanDistance(neighbor, targetCenter);
                }

                // If no terrain neighbors and open set is empty, terrain phase is done
                if (!foundTerrainNeighbor && openSet.Count == 0)
                {
                    terrainPhaseComplete = true;
                    break;
                }
            }

            // Phase 2: If terrain ended without reaching wall, bridge the gap through passable cells
            if (reachedCell == null && terrainPhaseComplete && bestTerrainEndCell.HasValue)
            {
                // Reset for phase 2, starting from where terrain ended
                openSet.Clear();
                // Keep closedSet to avoid revisiting terrain cells

                IntVec3 phase2Start = bestTerrainEndCell.Value;
                openSet.Add(phase2Start);
                // gScore and fScore already set for this cell

                while (openSet.Count > 0 && iterations < maxIterations)
                {
                    iterations++;

                    IntVec3 current = GetLowestFScore(openSet, fScore);
                    openSet.Remove(current);
                    closedSet.Add(current);

                    // First check for the specific wall, then fall back to any impassable edifice
                    if (wallDef != null && IsAdjacentToWallDef(map, current, wallDef))
                    {
                        reachedCell = current;
                        break;
                    }
                    if (IsAdjacentToImpassableEdifice(map, current))
                    {
                        reachedCell = current;
                        break;
                    }

                    // Explore cardinal neighbors - any passable cell in phase 2
                    foreach (IntVec3 neighbor in CardinalNeighbors(current))
                    {
                        if (!neighbor.InBounds(map))
                            continue;
                        if (closedSet.Contains(neighbor))
                            continue;
                        // In phase 2, allow any passable cell (not just terrain)
                        if (neighbor.Impassable(map))
                            continue;

                        int tentativeGScore = gScore.TryGetValue(current, out int g) ? g + 1 : 1;

                        if (!openSet.Contains(neighbor))
                        {
                            openSet.Add(neighbor);
                        }
                        else if (gScore.TryGetValue(neighbor, out int existingG) && tentativeGScore >= existingG)
                        {
                            continue;
                        }

                        cameFrom[neighbor] = current;
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = tentativeGScore + ManhattanDistance(neighbor, targetCenter);
                    }
                }
            }

            // Reconstruct path if we reached the structure
            if (reachedCell == null)
                return new List<IntVec3>();

            List<IntVec3> path = new List<IntVec3>();
            IntVec3 pathCell = reachedCell.Value;

            while (cameFrom.ContainsKey(pathCell) && cameFrom[pathCell] != pathCell)
            {
                path.Add(pathCell);
                pathCell = cameFrom[pathCell];
            }
            path.Add(pathCell); // Add start cell

            path.Reverse();
            return path;
        }

        /// <summary>
        /// Manhattan distance heuristic for A* - sum of absolute differences in x and z.
        /// Admissible for grid movement (never overestimates).
        /// </summary>
        private static int ManhattanDistance(IntVec3 a, IntVec3 b)
        {
            return System.Math.Abs(a.x - b.x) + System.Math.Abs(a.z - b.z);
        }

        /// <summary>
        /// Finds the cell with the lowest fScore in the open set.
        /// Simple O(n) scan - suitable for the expected set sizes.
        /// </summary>
        private static IntVec3 GetLowestFScore(HashSet<IntVec3> openSet, Dictionary<IntVec3, int> fScore)
        {
            IntVec3 best = default;
            int bestScore = int.MaxValue;

            foreach (IntVec3 cell in openSet)
            {
                int score = fScore.TryGetValue(cell, out int f) ? f : int.MaxValue;
                if (score < bestScore)
                {
                    bestScore = score;
                    best = cell;
                }
            }

            return best;
        }

        /// <summary>
        /// Checks if a cell is adjacent to a specific wall ThingDef.
        /// Used to detect the actual settlement perimeter wall (OrbitalAncientFortifiedWall).
        /// </summary>
        private static bool IsAdjacentToWallDef(Map map, IntVec3 cell, ThingDef wallDef)
        {
            foreach (IntVec3 neighbor in CardinalNeighbors(cell))
            {
                if (!neighbor.InBounds(map))
                    continue;

                List<Thing> things = map.thingGrid.ThingsListAt(neighbor);
                foreach (Thing thing in things)
                {
                    if (thing.def == wallDef)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Checks if a cell is adjacent to an impassable edifice (wall, door, etc.).
        /// Used as a fallback when the specific wall type isn't found.
        /// </summary>
        private static bool IsAdjacentToImpassableEdifice(Map map, IntVec3 cell)
        {
            foreach (IntVec3 neighbor in CardinalNeighbors(cell))
            {
                if (!neighbor.InBounds(map))
                    continue;

                // Check if neighbor cell contains an impassable edifice
                Building edifice = neighbor.GetEdifice(map);
                if (edifice != null && edifice.def.passability == Traversability.Impassable)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Places visible VE pipes along a traced path for fluid refueling.
        /// Skips cells inside structure rect (already have pipes from wall placement).
        /// </summary>
        private static int PlacePipesAlongPath(
            Map map,
            List<IntVec3> path,
            CellRect structureRect,
            List<ThingDef> visiblePipeDefs,
            HashSet<IntVec3> placedCells)
        {
            int placedCount = 0;

            foreach (IntVec3 cell in path)
            {
                // Skip cells inside structure (already have pipes from wall placement)
                if (structureRect.Contains(cell))
                    continue;

                // Skip if we already placed here (multiple pads may share path sections)
                if (!placedCells.Add(cell))
                    continue;

                // Place visible VE pipes
                foreach (ThingDef pipeDef in visiblePipeDefs)
                {
                    // Skip if this pipe type already exists at this cell
                    if (HasThingAt(map, cell, pipeDef))
                        continue;

                    Thing pipe = ThingMaker.MakeThing(pipeDef);
                    GenSpawn.Spawn(pipe, cell, map);
                }
                placedCount++;
            }

            return placedCount;
        }

        /// <summary>
        /// Checks if a cell already has a thing of the specified type.
        /// </summary>
        private static bool HasThingAt(Map map, IntVec3 cell, ThingDef def)
        {
            List<Thing> thingsAtCell = map.thingGrid.ThingsListAt(cell);
            foreach (Thing thing in thingsAtCell)
            {
                if (thing.def == def)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Gets the four cardinal neighbors of a cell (N, S, E, W).
        /// RimWorld's GenAdj.CellsAdjacentCardinal expects a Thing, so we use this for IntVec3.
        /// </summary>
        private static IEnumerable<IntVec3> CardinalNeighbors(IntVec3 cell)
        {
            yield return new IntVec3(cell.x, 0, cell.z + 1); // North
            yield return new IntVec3(cell.x, 0, cell.z - 1); // South
            yield return new IntVec3(cell.x + 1, 0, cell.z); // East
            yield return new IntVec3(cell.x - 1, 0, cell.z); // West
        }
    }
}
