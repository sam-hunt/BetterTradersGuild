using System.Collections.Generic;
using System.Linq;
using RimWorld;
using Verse;

namespace BetterTradersGuild.Helpers.MapGeneration
{
    /// <summary>
    /// Extends conduit and pipe networks from main settlement structure
    /// to external landing pads by following OrbitalPlatform terrain strips.
    ///
    /// PURPOSE:
    /// Provides thematic realism for traders' guild refueling stations by
    /// connecting power/resource networks to ship landing areas.
    ///
    /// TECHNICAL APPROACH:
    /// - Detects landing pads by finding AncientShipBeacon things outside structure
    /// - Clusters beacons by terrain connectivity (handles large pads >50 cells)
    /// - Traces BFS paths from pad edges back to main structure following terrain
    /// - Places visible PowerConduit and VE pipes along the paths
    /// - Places a PowerSwitch at the connection point for player control
    ///
    /// LEARNING NOTE (External vs Internal Generation):
    /// External landing pads are NOT part of LayoutStructureSketch - they're
    /// procedurally generated by vanilla GenStep_OrbitalPlatform separately.
    /// We detect them post-generation via beacon markers.
    /// </summary>
    public static class LandingPadConduitExtender
    {
        /// <summary>
        /// Data structure representing a detected landing pad.
        /// </summary>
        public struct LandingPadInfo
        {
            public CellRect BoundingRect;
            public IntVec3 Centroid;
            public List<IntVec3> BeaconPositions;
        }

        /// <summary>
        /// Main entry point: Extends conduits/pipes from structure to all landing pads.
        /// Called after LayoutConduitPlacer.PlaceHiddenConduits() in the Postfix.
        /// </summary>
        /// <param name="map">The map being generated</param>
        /// <param name="sketch">The LayoutStructureSketch containing structure data</param>
        /// <returns>Number of conduit positions placed</returns>
        public static int ExtendConduitsToLandingPads(Map map, LayoutStructureSketch sketch)
        {
            if (sketch?.structureLayout == null)
                return 0;

            // Get main structure bounding rect
            CellRect structureRect = sketch.structureLayout.container;

            // Detect landing pads via beacons
            List<LandingPadInfo> landingPads = DetectLandingPads(map, structureRect);
            if (landingPads.Count == 0)
                return 0;

            // Get terrain and thing defs for placement
            TerrainDef orbitalPlatformTerrain = DefDatabase<TerrainDef>.GetNamedSilentFail("OrbitalPlatform");
            if (orbitalPlatformTerrain == null)
            {
                Log.Warning("[Better Traders Guild] Could not find OrbitalPlatform terrain def for landing pad conduit extension.");
                return 0;
            }

            // Use visible conduits for external paths (more visible to players)
            ThingDef powerConduitDef = DefDatabase<ThingDef>.GetNamed("PowerConduit");
            ThingDef powerSwitchDef = DefDatabase<ThingDef>.GetNamedSilentFail("PowerSwitch");
            List<ThingDef> visiblePipeDefs = GetVisiblePipeDefs();

            // Track all placed positions to avoid duplicates
            HashSet<IntVec3> placedCells = new HashSet<IntVec3>();
            int totalPlaced = 0;
            int switchesPlaced = 0;

            // For each landing pad, trace path to structure and place conduits
            foreach (LandingPadInfo pad in landingPads)
            {
                // Find path from pad edge to structure
                List<IntVec3> path = FindTerrainPathToStructure(map, pad, structureRect, orbitalPlatformTerrain);
                if (path.Count == 0)
                    continue;

                // Place conduits along path, with PowerSwitch at connection point
                int placed = PlaceConduitsAlongPath(map, path, structureRect, powerConduitDef, visiblePipeDefs, powerSwitchDef, placedCells, ref switchesPlaced);
                totalPlaced += placed;
            }

            if (switchesPlaced > 0)
            {
                Log.Message($"[Better Traders Guild] Placed {switchesPlaced} PowerSwitch(es) at landing pad connection points.");
            }

            return totalPlaced;
        }

        /// <summary>
        /// Visible VE pipe defNames corresponding to the hidden versions.
        /// Maps to visible pipes for networks where we provide tank+valve prefabs.
        /// </summary>
        private static readonly string[] VisiblePipeDefNames = new string[]
        {
            // VE Chemfuel (VanillaExpanded.VChemfuelE)
            "VCHE_ChemfuelPipe",
            "VCHE_DeepchemPipe",
            // VE Nutrient Paste (VanillaExpanded.VNutrientE)
            "VNPE_NutrientPastePipe",
            // VE Gravships (vanillaexpanded.gravship)
            "VGE_OxygenPipe",
            "VGE_AstrofuelPipe",
        };

        /// <summary>
        /// Gets visible VE pipe ThingDefs for installed mods.
        /// These are used on external landing pad paths instead of hidden pipes.
        /// </summary>
        private static List<ThingDef> GetVisiblePipeDefs()
        {
            List<ThingDef> visiblePipes = new List<ThingDef>();

            foreach (string defName in VisiblePipeDefNames)
            {
                ThingDef def = DefDatabase<ThingDef>.GetNamedSilentFail(defName);
                if (def != null)
                {
                    visiblePipes.Add(def);
                }
            }

            return visiblePipes;
        }

        /// <summary>
        /// Detects landing pads by finding and clustering AncientShipBeacon things.
        /// Filters out beacons inside structure rect (handled separately via prefabs).
        /// </summary>
        private static List<LandingPadInfo> DetectLandingPads(Map map, CellRect structureRect)
        {
            // Find AncientShipBeacon ThingDef
            ThingDef beaconDef = DefDatabase<ThingDef>.GetNamedSilentFail("AncientShipBeacon");
            if (beaconDef == null)
                return new List<LandingPadInfo>();

            // Get all beacons on map
            List<Thing> allBeacons = map.listerThings.ThingsOfDef(beaconDef);
            if (allBeacons.Count == 0)
                return new List<LandingPadInfo>();

            // Filter to beacons OUTSIDE structure rect
            List<Thing> externalBeacons = allBeacons
                .Where(b => !structureRect.Contains(b.Position))
                .ToList();

            if (externalBeacons.Count == 0)
                return new List<LandingPadInfo>();

            // Get terrain for connectivity check
            TerrainDef orbitalPlatformTerrain = DefDatabase<TerrainDef>.GetNamedSilentFail("OrbitalPlatform");
            if (orbitalPlatformTerrain == null)
                return new List<LandingPadInfo>();

            // Cluster beacons by terrain connectivity
            List<List<Thing>> clusters = ClusterBeaconsByTerrainConnectivity(map, externalBeacons, orbitalPlatformTerrain);

            // Convert clusters to LandingPadInfo
            List<LandingPadInfo> landingPads = new List<LandingPadInfo>();
            foreach (List<Thing> cluster in clusters)
            {
                if (cluster.Count == 0)
                    continue;

                // Calculate bounding rect from beacon positions
                int minX = cluster.Min(b => b.Position.x);
                int maxX = cluster.Max(b => b.Position.x);
                int minZ = cluster.Min(b => b.Position.z);
                int maxZ = cluster.Max(b => b.Position.z);

                CellRect boundingRect = new CellRect(minX, minZ, maxX - minX + 1, maxZ - minZ + 1);
                IntVec3 centroid = boundingRect.CenterCell;

                landingPads.Add(new LandingPadInfo
                {
                    BoundingRect = boundingRect,
                    Centroid = centroid,
                    BeaconPositions = cluster.Select(b => b.Position).ToList()
                });
            }

            return landingPads;
        }

        /// <summary>
        /// Clusters beacons by terrain connectivity using flood-fill.
        /// Beacons that share connected OrbitalPlatform terrain belong to same pad.
        /// Handles large landing pads where beacons can be >50 cells apart.
        /// </summary>
        private static List<List<Thing>> ClusterBeaconsByTerrainConnectivity(
            Map map, List<Thing> beacons, TerrainDef terrainDef)
        {
            List<List<Thing>> clusters = new List<List<Thing>>();
            HashSet<Thing> unclustered = new HashSet<Thing>(beacons);

            while (unclustered.Count > 0)
            {
                // Start new cluster with first unclustered beacon
                Thing startBeacon = unclustered.First();
                unclustered.Remove(startBeacon);

                List<Thing> cluster = new List<Thing> { startBeacon };

                // Find all terrain cells reachable from this beacon
                HashSet<IntVec3> reachableTerrain = FloodFillTerrain(map, startBeacon.Position, terrainDef);

                // Check which other beacons are on this terrain
                List<Thing> toAdd = new List<Thing>();
                foreach (Thing beacon in unclustered)
                {
                    if (reachableTerrain.Contains(beacon.Position))
                    {
                        toAdd.Add(beacon);
                    }
                }

                // Add connected beacons to cluster
                foreach (Thing beacon in toAdd)
                {
                    cluster.Add(beacon);
                    unclustered.Remove(beacon);
                }

                clusters.Add(cluster);
            }

            return clusters;
        }

        /// <summary>
        /// Flood-fills from a starting cell, returning all connected cells with matching terrain.
        /// Uses BFS to avoid stack overflow on large areas.
        /// </summary>
        private static HashSet<IntVec3> FloodFillTerrain(Map map, IntVec3 start, TerrainDef terrainDef)
        {
            HashSet<IntVec3> visited = new HashSet<IntVec3>();
            Queue<IntVec3> queue = new Queue<IntVec3>();

            // Start from the beacon position - check if it's on platform terrain
            // If not, check immediate neighbors for platform terrain to start from
            if (map.terrainGrid.TerrainAt(start) == terrainDef)
            {
                queue.Enqueue(start);
                visited.Add(start);
            }
            else
            {
                // Beacon might be on different terrain, check neighbors
                foreach (IntVec3 neighbor in CardinalNeighbors(start))
                {
                    if (neighbor.InBounds(map) && map.terrainGrid.TerrainAt(neighbor) == terrainDef)
                    {
                        queue.Enqueue(neighbor);
                        visited.Add(neighbor);
                    }
                }
            }

            // BFS flood fill
            while (queue.Count > 0)
            {
                IntVec3 current = queue.Dequeue();

                foreach (IntVec3 neighbor in CardinalNeighbors(current))
                {
                    if (!neighbor.InBounds(map))
                        continue;
                    if (visited.Contains(neighbor))
                        continue;
                    if (map.terrainGrid.TerrainAt(neighbor) != terrainDef)
                        continue;

                    visited.Add(neighbor);
                    queue.Enqueue(neighbor);
                }
            }

            return visited;
        }

        /// <summary>
        /// Finds a path from landing pad edge toward main structure,
        /// following OrbitalPlatform terrain using BFS.
        /// </summary>
        private static List<IntVec3> FindTerrainPathToStructure(
            Map map,
            LandingPadInfo padInfo,
            CellRect structureRect,
            TerrainDef terrainDef)
        {
            // Find the edge of the pad closest to the structure
            IntVec3 structureCenter = structureRect.CenterCell;
            IntVec3 padCenter = padInfo.Centroid;

            // Determine which side of the pad faces the structure
            IntVec3 startCell = FindClosestPadEdgeToStructure(padInfo.BoundingRect, structureCenter);

            // BFS from pad edge toward structure
            return FindTerrainPathBFS(map, startCell, structureRect, terrainDef, maxIterations: 2000);
        }

        /// <summary>
        /// Finds the cell on the pad's bounding rect edge closest to the structure center.
        /// </summary>
        private static IntVec3 FindClosestPadEdgeToStructure(CellRect padRect, IntVec3 structureCenter)
        {
            // Check which direction the structure is from the pad
            IntVec3 padCenter = padRect.CenterCell;
            int dx = structureCenter.x - padCenter.x;
            int dz = structureCenter.z - padCenter.z;

            // Pick edge based on direction
            if (System.Math.Abs(dx) > System.Math.Abs(dz))
            {
                // Structure is more horizontal (left/right)
                if (dx > 0)
                {
                    // Structure is to the right, use right edge
                    return new IntVec3(padRect.maxX, 0, padRect.CenterCell.z);
                }
                else
                {
                    // Structure is to the left, use left edge
                    return new IntVec3(padRect.minX, 0, padRect.CenterCell.z);
                }
            }
            else
            {
                // Structure is more vertical (up/down)
                if (dz > 0)
                {
                    // Structure is above, use top edge
                    return new IntVec3(padRect.CenterCell.x, 0, padRect.maxZ);
                }
                else
                {
                    // Structure is below, use bottom edge
                    return new IntVec3(padRect.CenterCell.x, 0, padRect.minZ);
                }
            }
        }

        /// <summary>
        /// BFS pathfinding that follows specific terrain type.
        /// Returns path from start toward target rect.
        /// </summary>
        private static List<IntVec3> FindTerrainPathBFS(
            Map map,
            IntVec3 startCell,
            CellRect targetRect,
            TerrainDef terrainDef,
            int maxIterations = 1000)
        {
            // If start cell isn't on platform terrain, search nearby for terrain to start from
            if (!startCell.InBounds(map) || map.terrainGrid.TerrainAt(startCell) != terrainDef)
            {
                // Search in expanding rings for platform terrain
                IntVec3? foundStart = null;
                for (int radius = 1; radius <= 5 && foundStart == null; radius++)
                {
                    foreach (IntVec3 cell in GenRadial.RadialCellsAround(startCell, radius, false))
                    {
                        if (cell.InBounds(map) && map.terrainGrid.TerrainAt(cell) == terrainDef)
                        {
                            foundStart = cell;
                            break;
                        }
                    }
                }

                if (foundStart == null)
                    return new List<IntVec3>();

                startCell = foundStart.Value;
            }

            // BFS to find path to structure rect
            Dictionary<IntVec3, IntVec3> cameFrom = new Dictionary<IntVec3, IntVec3>();
            Queue<IntVec3> queue = new Queue<IntVec3>();

            queue.Enqueue(startCell);
            cameFrom[startCell] = startCell; // Mark start as visited

            int iterations = 0;
            IntVec3? reachedCell = null;

            while (queue.Count > 0 && iterations < maxIterations)
            {
                iterations++;
                IntVec3 current = queue.Dequeue();

                // Check if we've reached the structure rect (adjacent to it)
                if (IsAdjacentToRect(current, targetRect))
                {
                    reachedCell = current;
                    break;
                }

                // Explore cardinal neighbors
                foreach (IntVec3 neighbor in CardinalNeighbors(current))
                {
                    if (!neighbor.InBounds(map))
                        continue;
                    if (cameFrom.ContainsKey(neighbor))
                        continue;
                    if (map.terrainGrid.TerrainAt(neighbor) != terrainDef)
                        continue;

                    cameFrom[neighbor] = current;
                    queue.Enqueue(neighbor);
                }
            }

            // Reconstruct path if we reached the structure
            if (reachedCell == null)
                return new List<IntVec3>();

            List<IntVec3> path = new List<IntVec3>();
            IntVec3 pathCell = reachedCell.Value;

            while (cameFrom.ContainsKey(pathCell) && cameFrom[pathCell] != pathCell)
            {
                path.Add(pathCell);
                pathCell = cameFrom[pathCell];
            }
            path.Add(pathCell); // Add start cell

            // Path is from structure to pad, reverse if needed
            // Actually we want pad-to-structure direction for placing, which this already is
            path.Reverse();

            return path;
        }

        /// <summary>
        /// Checks if a cell is adjacent to (touching) the given rect.
        /// </summary>
        private static bool IsAdjacentToRect(IntVec3 cell, CellRect rect)
        {
            // Check if any cardinal neighbor is inside the rect
            foreach (IntVec3 neighbor in CardinalNeighbors(cell))
            {
                if (rect.Contains(neighbor))
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Places visible conduits and VE pipes along a traced path.
        /// Places a PowerSwitch at the connection point (last cell before structure).
        /// Skips cells inside structure rect (already have conduits from walls).
        /// Skips cells that already have conduits (deduplication).
        /// </summary>
        private static int PlaceConduitsAlongPath(
            Map map,
            List<IntVec3> path,
            CellRect structureRect,
            ThingDef powerConduitDef,
            List<ThingDef> visiblePipeDefs,
            ThingDef powerSwitchDef,
            HashSet<IntVec3> placedCells,
            ref int switchesPlaced)
        {
            int placedCount = 0;

            // Find the last cell adjacent to structure (where we'll place the PowerSwitch)
            // Path goes from pad toward structure, so we look for the last cell outside structure
            IntVec3? switchCell = null;
            for (int i = path.Count - 1; i >= 0; i--)
            {
                IntVec3 cell = path[i];
                if (!structureRect.Contains(cell) && IsAdjacentToRect(cell, structureRect))
                {
                    switchCell = cell;
                    break;
                }
            }

            foreach (IntVec3 cell in path)
            {
                // Skip cells inside structure (already have conduits from wall placement)
                if (structureRect.Contains(cell))
                    continue;

                // Skip if we already placed here (multiple pads may share path sections)
                if (!placedCells.Add(cell))
                    continue;

                // Skip if conduit already exists at this cell
                if (HasConduitAt(map, cell, powerConduitDef))
                    continue;

                // Place PowerSwitch at the connection point, conduit elsewhere
                if (switchCell.HasValue && cell == switchCell.Value && powerSwitchDef != null)
                {
                    Thing powerSwitch = ThingMaker.MakeThing(powerSwitchDef);
                    GenSpawn.Spawn(powerSwitch, cell, map);
                    switchesPlaced++;
                }
                else
                {
                    // Place visible power conduit
                    Thing conduit = ThingMaker.MakeThing(powerConduitDef);
                    GenSpawn.Spawn(conduit, cell, map);
                }
                placedCount++;

                // Also place visible VE pipes
                foreach (ThingDef pipeDef in visiblePipeDefs)
                {
                    Thing pipe = ThingMaker.MakeThing(pipeDef);
                    GenSpawn.Spawn(pipe, cell, map);
                }
            }

            return placedCount;
        }

        /// <summary>
        /// Checks if a cell already has a conduit of the specified type.
        /// </summary>
        private static bool HasConduitAt(Map map, IntVec3 cell, ThingDef conduitDef)
        {
            List<Thing> thingsAtCell = map.thingGrid.ThingsListAt(cell);
            foreach (Thing thing in thingsAtCell)
            {
                if (thing.def == conduitDef)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Gets the four cardinal neighbors of a cell (N, S, E, W).
        /// RimWorld's GenAdj.CellsAdjacentCardinal expects a Thing, so we use this for IntVec3.
        /// </summary>
        private static IEnumerable<IntVec3> CardinalNeighbors(IntVec3 cell)
        {
            yield return new IntVec3(cell.x, 0, cell.z + 1); // North
            yield return new IntVec3(cell.x, 0, cell.z - 1); // South
            yield return new IntVec3(cell.x + 1, 0, cell.z); // East
            yield return new IntVec3(cell.x - 1, 0, cell.z); // West
        }
    }
}
