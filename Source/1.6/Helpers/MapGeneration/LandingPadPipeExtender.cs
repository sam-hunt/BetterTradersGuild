using System.Collections.Generic;
using RimWorld;
using Verse;

namespace BetterTradersGuild.Helpers.MapGeneration
{
    /// <summary>
    /// Extends VE pipe networks from main settlement structure to external
    /// landing pads by following OrbitalPlatform terrain strips.
    ///
    /// PURPOSE:
    /// Provides thematic realism for traders' guild refueling stations by
    /// connecting fluid resource networks (chemfuel, nutrient paste, oxygen,
    /// astrofuel) to ship landing areas for docked vessel resupply.
    ///
    /// TECHNICAL APPROACH:
    /// - Uses LandingPadDetector to find external landing pads via beacon markers
    /// - Traces BFS paths from pad edges back to main structure following terrain
    /// - Places visible VE pipes along the paths
    ///
    /// LEARNING NOTE (External vs Internal Generation):
    /// External landing pads are NOT part of LayoutStructureSketch - they're
    /// procedurally generated by vanilla GenStep_OrbitalPlatform separately.
    /// We detect them post-generation via beacon markers.
    /// </summary>
    public static class LandingPadPipeExtender
    {
        /// <summary>
        /// Main entry point: Extends VE pipes from structure to all landing pads.
        /// Called after LayoutConduitPlacer.PlaceHiddenConduits() in the Postfix.
        /// </summary>
        /// <param name="map">The map being generated</param>
        /// <param name="sketch">The LayoutStructureSketch containing structure data</param>
        /// <returns>Number of pipe positions placed</returns>
        public static int ExtendPipesToLandingPads(Map map, LayoutStructureSketch sketch)
        {
            if (sketch?.structureLayout == null)
                return 0;

            // Get main structure bounding rect
            CellRect structureRect = sketch.structureLayout.container;

            // Detect landing pads via beacons (external to structure)
            List<LandingPadDetector.LandingPadInfo> landingPads = LandingPadDetector.DetectOutsideRect(map, structureRect);
            if (landingPads.Count == 0)
                return 0;

            Log.Message($"[Better Traders Guild] Detected {landingPads.Count} external landing pad(s) for pipe extension.");

            // Get terrain and thing defs for placement
            TerrainDef orbitalPlatformTerrain = DefDatabase<TerrainDef>.GetNamedSilentFail("OrbitalPlatform");
            if (orbitalPlatformTerrain == null)
            {
                Log.Warning("[Better Traders Guild] Could not find OrbitalPlatform terrain def for landing pad pipe extension.");
                return 0;
            }

            // Get the orbital wall def for structure detection
            // This ensures we connect to actual structure walls, not random impassable things
            ThingDef orbitalWallDef = DefDatabase<ThingDef>.GetNamedSilentFail("OrbitalAncientFortifiedWall");
            if (orbitalWallDef == null)
            {
                Log.Warning("[Better Traders Guild] Could not find OrbitalAncientFortifiedWall def for landing pad pipe extension.");
                return 0;
            }

            // Get visible VE pipe defs for fluid networks (no power - ships don't need to buy electricity)
            List<ThingDef> visiblePipeDefs = GetVisiblePipeDefs();
            if (visiblePipeDefs.Count == 0)
                return 0; // No pipe mods installed, nothing to extend

            // Track all placed positions to avoid duplicates
            HashSet<IntVec3> placedCells = new HashSet<IntVec3>();
            int totalPlaced = 0;

            // For each landing pad, trace path to structure and place pipes
            foreach (LandingPadDetector.LandingPadInfo pad in landingPads)
            {
                // Find path from pad edge to structure wall
                List<IntVec3> path = FindTerrainPathToStructure(map, pad, structureRect, orbitalPlatformTerrain, orbitalWallDef);
                if (path.Count == 0)
                {
                    Log.Warning($"[Better Traders Guild] Landing pad at {pad.Centroid}: no terrain path found to structure.");
                    continue;
                }

                // Place pipes along path
                int placed = PlacePipesAlongPath(map, path, structureRect, visiblePipeDefs, placedCells);
                totalPlaced += placed;
            }

            return totalPlaced;
        }

        /// <summary>
        /// Visible VE pipe defNames corresponding to the hidden versions.
        /// Maps to visible pipes for networks where we provide tank+valve prefabs.
        /// </summary>
        private static readonly string[] VisiblePipeDefNames = new string[]
        {
            // VE Chemfuel (VanillaExpanded.VChemfuelE)
            "VCHE_ChemfuelPipe",
            "VCHE_DeepchemPipe",
            // VE Nutrient Paste (VanillaExpanded.VNutrientE)
            "VNPE_NutrientPastePipe",
            // VE Gravships (vanillaexpanded.gravship)
            "VGE_OxygenPipe",
            "VGE_AstrofuelPipe",
        };

        /// <summary>
        /// Gets visible VE pipe ThingDefs for installed mods.
        /// These are used on external landing pad paths instead of hidden pipes.
        /// </summary>
        private static List<ThingDef> GetVisiblePipeDefs()
        {
            List<ThingDef> visiblePipes = new List<ThingDef>();

            foreach (string defName in VisiblePipeDefNames)
            {
                ThingDef def = DefDatabase<ThingDef>.GetNamedSilentFail(defName);
                if (def != null)
                {
                    visiblePipes.Add(def);
                }
            }

            return visiblePipes;
        }

        /// <summary>
        /// Finds a path from landing pad edge toward main structure,
        /// following OrbitalPlatform terrain using BFS.
        /// </summary>
        private static List<IntVec3> FindTerrainPathToStructure(
            Map map,
            LandingPadDetector.LandingPadInfo padInfo,
            CellRect structureRect,
            TerrainDef terrainDef,
            ThingDef wallDef)
        {
            // Find the edge of the pad closest to the structure
            IntVec3 structureCenter = structureRect.CenterCell;

            // Determine which side of the pad faces the structure
            IntVec3 startCell = FindClosestPadEdgeToStructure(padInfo.BoundingRect, structureCenter);

            // BFS from pad edge toward structure wall
            return FindTerrainPathBFS(map, startCell, structureRect, terrainDef, wallDef, maxIterations: 2000);
        }

        /// <summary>
        /// Finds the cell on the pad's bounding rect edge closest to the structure center.
        /// </summary>
        private static IntVec3 FindClosestPadEdgeToStructure(CellRect padRect, IntVec3 structureCenter)
        {
            // Check which direction the structure is from the pad
            IntVec3 padCenter = padRect.CenterCell;
            int dx = structureCenter.x - padCenter.x;
            int dz = structureCenter.z - padCenter.z;

            // Pick edge based on direction
            if (System.Math.Abs(dx) > System.Math.Abs(dz))
            {
                // Structure is more horizontal (left/right)
                if (dx > 0)
                {
                    // Structure is to the right, use right edge
                    return new IntVec3(padRect.maxX, 0, padRect.CenterCell.z);
                }
                else
                {
                    // Structure is to the left, use left edge
                    return new IntVec3(padRect.minX, 0, padRect.CenterCell.z);
                }
            }
            else
            {
                // Structure is more vertical (up/down)
                if (dz > 0)
                {
                    // Structure is above, use top edge
                    return new IntVec3(padRect.CenterCell.x, 0, padRect.maxZ);
                }
                else
                {
                    // Structure is below, use bottom edge
                    return new IntVec3(padRect.CenterCell.x, 0, padRect.minZ);
                }
            }
        }

        /// <summary>
        /// BFS pathfinding that follows specific terrain type until reaching the target wall type.
        /// Returns path from start toward target rect.
        /// </summary>
        private static List<IntVec3> FindTerrainPathBFS(
            Map map,
            IntVec3 startCell,
            CellRect targetRect,
            TerrainDef terrainDef,
            ThingDef wallDef,
            int maxIterations = 1000)
        {
            // If start cell isn't on platform terrain, search nearby for terrain to start from
            if (!startCell.InBounds(map) || map.terrainGrid.TerrainAt(startCell) != terrainDef)
            {
                // Search in expanding rings for platform terrain
                IntVec3? foundStart = null;
                for (int radius = 1; radius <= 5 && foundStart == null; radius++)
                {
                    foreach (IntVec3 cell in GenRadial.RadialCellsAround(startCell, radius, false))
                    {
                        if (cell.InBounds(map) && map.terrainGrid.TerrainAt(cell) == terrainDef)
                        {
                            foundStart = cell;
                            break;
                        }
                    }
                }

                if (foundStart == null)
                    return new List<IntVec3>();

                startCell = foundStart.Value;
            }

            // BFS to find path to structure wall
            Dictionary<IntVec3, IntVec3> cameFrom = new Dictionary<IntVec3, IntVec3>();
            Queue<IntVec3> queue = new Queue<IntVec3>();

            queue.Enqueue(startCell);
            cameFrom[startCell] = startCell; // Mark start as visited

            int iterations = 0;
            IntVec3? reachedCell = null;

            while (queue.Count > 0 && iterations < maxIterations)
            {
                iterations++;
                IntVec3 current = queue.Dequeue();

                // Check if we've reached the actual structure wall (OrbitalAncientFortifiedWall)
                // This ensures we connect to the real structure, not random impassable things
                // or stop early at the bounding box edge when there's a recess
                if (IsAdjacentToWallDef(map, current, wallDef))
                {
                    reachedCell = current;
                    break;
                }

                // Explore cardinal neighbors
                foreach (IntVec3 neighbor in CardinalNeighbors(current))
                {
                    if (!neighbor.InBounds(map))
                        continue;
                    if (cameFrom.ContainsKey(neighbor))
                        continue;
                    if (map.terrainGrid.TerrainAt(neighbor) != terrainDef)
                        continue;

                    cameFrom[neighbor] = current;
                    queue.Enqueue(neighbor);
                }
            }

            // Reconstruct path if we reached the structure
            if (reachedCell == null)
                return new List<IntVec3>();

            List<IntVec3> path = new List<IntVec3>();
            IntVec3 pathCell = reachedCell.Value;

            while (cameFrom.ContainsKey(pathCell) && cameFrom[pathCell] != pathCell)
            {
                path.Add(pathCell);
                pathCell = cameFrom[pathCell];
            }
            path.Add(pathCell); // Add start cell

            // Path is from structure to pad, reverse if needed
            // Actually we want pad-to-structure direction for placing, which this already is
            path.Reverse();

            return path;
        }

        /// <summary>
        /// Checks if a cell is adjacent to a specific wall ThingDef.
        /// Used to detect actual structure edges by looking for the specific wall type.
        /// </summary>
        private static bool IsAdjacentToWallDef(Map map, IntVec3 cell, ThingDef wallDef)
        {
            foreach (IntVec3 neighbor in CardinalNeighbors(cell))
            {
                if (!neighbor.InBounds(map))
                    continue;

                List<Thing> things = map.thingGrid.ThingsListAt(neighbor);
                foreach (Thing thing in things)
                {
                    if (thing.def == wallDef)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Places visible VE pipes along a traced path for fluid refueling.
        /// Skips cells inside structure rect (already have pipes from wall placement).
        /// </summary>
        private static int PlacePipesAlongPath(
            Map map,
            List<IntVec3> path,
            CellRect structureRect,
            List<ThingDef> visiblePipeDefs,
            HashSet<IntVec3> placedCells)
        {
            int placedCount = 0;

            foreach (IntVec3 cell in path)
            {
                // Skip cells inside structure (already have pipes from wall placement)
                if (structureRect.Contains(cell))
                    continue;

                // Skip if we already placed here (multiple pads may share path sections)
                if (!placedCells.Add(cell))
                    continue;

                // Place visible VE pipes
                foreach (ThingDef pipeDef in visiblePipeDefs)
                {
                    // Skip if this pipe type already exists at this cell
                    if (HasThingAt(map, cell, pipeDef))
                        continue;

                    Thing pipe = ThingMaker.MakeThing(pipeDef);
                    GenSpawn.Spawn(pipe, cell, map);
                }
                placedCount++;
            }

            return placedCount;
        }

        /// <summary>
        /// Checks if a cell already has a thing of the specified type.
        /// </summary>
        private static bool HasThingAt(Map map, IntVec3 cell, ThingDef def)
        {
            List<Thing> thingsAtCell = map.thingGrid.ThingsListAt(cell);
            foreach (Thing thing in thingsAtCell)
            {
                if (thing.def == def)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Gets the four cardinal neighbors of a cell (N, S, E, W).
        /// RimWorld's GenAdj.CellsAdjacentCardinal expects a Thing, so we use this for IntVec3.
        /// </summary>
        private static IEnumerable<IntVec3> CardinalNeighbors(IntVec3 cell)
        {
            yield return new IntVec3(cell.x, 0, cell.z + 1); // North
            yield return new IntVec3(cell.x, 0, cell.z - 1); // South
            yield return new IntVec3(cell.x + 1, 0, cell.z); // East
            yield return new IntVec3(cell.x - 1, 0, cell.z); // West
        }
    }
}
